import os
from typing import Optional
from fastapi import APIRouter, HTTPException, Body
from playwright.async_api import async_playwright, TimeoutError as PWTimeout

router = APIRouter()

# In-memory storage of a logged-in session (persists until container restarts)
_ETSY_STORAGE_STATE: Optional[dict] = None

def _need(name: str) -> str:
    v = os.getenv(name, "")
    if not v:
        raise HTTPException(status_code=400, detail=f"Missing env var: {name}")
    return v

async def _login_with_email_password(email: str, password: str, otp_code: Optional[str] = None):
    """
    Logs into Etsy using credentials stored in env vars.
    If 2FA required and no otp_code provided -> return twofa_required.
    Returns dict: {ok: bool, twofa_required: bool, storage_state: dict|None, message: str}
    """
    ua = os.getenv("ETSY_USER_AGENT", "")
    launch_args = {"headless": True, "args": ["--no-sandbox", "--disable-dev-shm-usage"]}
    async with async_playwright() as p:
        browser = await p.chromium.launch(**launch_args)
        context_kwargs = {}
        if ua:
            context_kwargs["user_agent"] = ua
        # Helpful hints for consistency:
        context_kwargs.update({"locale": "en-GB", "timezone_id": "Europe/London"})
        context = await browser.new_context(**context_kwargs)
        page = await context.new_page()
        try:
            await page.goto("https://www.etsy.com/signin", timeout=60000)

            # Accept cookie banner if present (best effort)
            for sel in ["button:has-text('Accept all')", "button:has-text('Accept')", "[data-gdpr-single-accept]", "#gdpr-single-accept"]:
                try:
                    if await page.locator(sel).first.is_visible(timeout=1500):
                        await page.locator(sel).first.click()
                        break
                except Exception:
                    pass

            # Email
            await page.fill("input[name='email'], #join_neu_email_field", email)
            await page.locator("button:has-text('Continue'), button[type='submit']").first.click()

            # Password
            await page.wait_for_selector("input[name='password'], #join_neu_password_field", timeout=30000)
            await page.fill("input[name='password'], #join_neu_password_field", password)
            await page.locator("button:has-text('Sign in'), button[type='submit']").first.click()

            # Detect logged in or 2FA
            logged_in = page.locator("[data-id='your-account-panel-toggle'], a[href*='your/account']")
            otp_input = page.locator("input[type='text'][name*='code'], input[name='code'], input[id*='code']")

            # quick wait
            await page.wait_for_timeout(1200)
            if await logged_in.count() > 0:
                state = await context.storage_state()
                await browser.close()
                return {"ok": True, "twofa_required": False, "storage_state": state, "message": "Logged in"}

            twofa = False
            try:
                twofa = await otp_input.first.is_visible(timeout=4000)
            except Exception:
                twofa = False

            if twofa:
                if not otp_code:
                    await browser.close()
                    return {"ok": False, "twofa_required": True, "storage_state": None, "message": "2FA required"}
                await otp_input.first.fill(otp_code)
                for sel in ["button:has-text('Confirm')", "button:has-text('Verify')", "button[type='submit']"]:
                    try:
                        if await page.locator(sel).first.is_visible(timeout=1500):
                            await page.locator(sel).first.click()
                            break
                    except Exception:
                        pass
                try:
                    await logged_in.first.wait_for(timeout=30000)
                    state = await context.storage_state()
                    await browser.close()
                    return {"ok": True, "twofa_required": False, "storage_state": state, "message": "Logged in with 2FA"}
                except PWTimeout:
                    await browser.close()
                    return {"ok": False, "twofa_required": True, "storage_state": None, "message": "2FA failed or timed out"}

            await browser.close()
            return {"ok": False, "twofa_required": False, "storage_state": None, "message": "Login failed"}
        except Exception as e:
            try:
                await browser.close()
            except Exception:
                pass
            return {"ok": False, "twofa_required": False, "storage_state": None, "message": f"Error: {e}"}

@router.post("/etsy/try-login")
async def etsy_try_login(payload: dict = Body(default={})):
    """
    First call without body → if 2FA needed returns HTTP 428.
    Second call with {"otp_code":"123456"} completes login.
    """
    email = _need("ETSY_EMAIL")
    password = _need("ETSY_PASSWORD")
    otp_code = (payload or {}).get("otp_code")

    result = await _login_with_email_password(email, password, otp_code=otp_code)
    global _ETSY_STORAGE_STATE
    if result.get("ok") and result.get("storage_state"):
        _ETSY_STORAGE_STATE = result["storage_state"]

    if result.get("twofa_required") and not result.get("ok"):
        # 428 Precondition Required → your frontend already handles this case
        raise HTTPException(status_code=428, detail="2FA required")

    return result

@router.get("/etsy/session-status")
async def etsy_session_status():
    ok = _ETSY_STORAGE_STATE is not None
    return {"service": "Etsy", "ok": ok, "message": "Session cached" if ok else "Not logged in"}

# Util for other modules
async def get_logged_in_context():
    if not _ETSY_STORAGE_STATE:
        raise HTTPException(status_code=401, detail="Etsy not logged in. Use /etsy/try-login first.")
    p = await async_playwright().start()
    browser = await p.chromium.launch(headless=True, args=["--no-sandbox", "--disable-dev-shm-usage"])
    context = await browser.new_context(storage_state=_ETSY_STORAGE_STATE)
    return p, browser, context
